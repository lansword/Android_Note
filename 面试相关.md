#      面试相关

1. **`android:style `和 `android:theme` 的区别**

   - 相同点：

     - 定义一样，都是用于控制UI样式；
     - 声明的位置一样，都位于values文件夹下的styles.xml下

   - 不同点：

     - Theme应用于全局，作用于整个Activity或者Application之上

     - Style应用于局部，作用于某个控件或者布局之上

   - 注：常见的Android内置的Theme
     - Theme.NoTitleBar : 不显示应用程序标题栏
     - Theme.NotitleBar.Fullscreen : 不显示应用程序标题栏并全屏
     - Theme.Light : 背景为白色
     - Theme.Light.NotitleBar : 背景白色并无标题栏
     - Theme.Light.NotitleBar.Fullscreen : 白色背景，无标题栏，全屏
     - Theme.Black
     - Theme.Black.NotitleBar
     - Theme.Black.NotitleBar.Fullscreen
     - Theme.Wallpaper : 用系统桌面为应用程序做背景
     - Theme.Wallpaper.NotitleBar
     - Theme.Wallpaper.NotitleBar.Fullscreen
     - Theme.Translucent
     - Theme.Translucent.NotitleBar
     - Theme.Translucent.NotitleBar.Fullscreen
     - Theme.Panel ：画板风格
     - Theme.Light.Panel ： 平板风格



2. **IntentService**

   - **作用**：处理异步请求 & 实现多线程，在IntentService内维护了一个工作线程来处理耗时操作，当任务执行完后，IntentService会自动停止。可以启动IntentService多次，而每一个耗时操作会以串行的方式在IntentService的onHandleIntent回调方法中执行

   - **使用方法**：

     ​    步骤1：继承 `IntentService`类，需复写`onHandleIntent()`方法
     ​    步骤2：在`Manifest.xml`中注册服务
     ​    步骤3：在`Activity`中开启`Service`服务

3. Activity 的四种启动模式

4. 动画种类及其工作原理

5. 线程启动方式，线程池原理清楚不？

6. 有哪些 ipc 方式

7. **Binder 原理流程介绍一下**

   - **Linux的IPC机制**：管道、消息队列、共享内存、Socket 等 ，主要使用共享内存

   - **传统Linux的内存共享的IPC机制的特点**：

     - 性能低下，一次数据传递需要经历：内存缓存区 --> 内核缓存区 --> 内存缓存区，需要 2 次数据拷贝
     - 接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间

   -  **Binder 跨进程通信原理**：基于内存映射来实现的

     - 如下图：![](https://github.com/spxcc/MyImages/blob/main/v2-cbd7d2befbed12d4c8896f236df96dbf_r.jpg)

   - **Binder 通信模型**:

     - Client/Server/ServiceManager/Binder驱动，如下图：![](https://github.com/spxcc/MyImages/blob/main/v2-729b3444cd784d882215a24067893d0e_r.jpg))

     - Client、Server、ServiceManager、Binder 驱动这几个组件在通信过程中扮演的角色就如同互联网中客户端（Client）、服务器（Server）、DNS域名服务器（ServiceManager）以及路由器（Binder 驱动）之前的关系

       - ***Binder 驱动***
         <u>*Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。*</u>

       - ***ServiceManager 与实名 Binder***
         <u>*ServiceManager 和 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。注册了名字的 Binder 叫实名 Binder，就像网站一样除了除了有 IP 地址意外还有自己的网址。Server 创建了 Binder，并为它起一个字符形式，可读易记得名字，将这个 Binder 实体连同名字一起以数据包的形式通过 Binder 驱动发送给 ServiceManager ，通知 ServiceManager 注册一个名为“张三”的 Binder，它位于某个 Server 中。驱动为这个穿越进程边界的 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager。ServiceManger 收到数据后从中取出名字和引用填入查找表。*</u>

         <u>*细心的读者可能会发现，ServierManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信。当前实现进程间通信又要用到进程间通信，这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！Binder 的实现比较巧妙，就是预先创造一只鸡来下蛋。ServiceManager 和其他进程同样采用 Bidner 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDERSETCONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体（**这就是那只预先造好的那只鸡**）。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。要注意的是，这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。*</u>

       - ***Client 获得实名 Binder 的引用***
         <u>*Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。*</u>

   - **Binder通信过程**:

     如图所示：![](https://github.com/spxcc/MyImages/blob/main/v2-1.jpg)

     - (1) 首先，一个进程使用 BINDER*SET*CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；

     - (2) Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。

     - (3) Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。

       

8. window, view, activity 关系
9. 性能优化方式讲一讲

10. 查找算法有哪些？手写二分查找
11. 知道哪些 Jetpack 组件？挑一两个讲讲原理
12. Sp 怎么支持跨进程？
13. 线程启动方式，线程池原理清楚不？